{{- if and .Info .Info.Title -}}
// {{ .Info.Title }} client
{{- end }}

{{- range $type := .Types }}

export interface {{ $type.GoName }} {
	{{- range $field := .Fields }}
	{{- if or $field.Optional (eq $field.APIName "id" "etag" "generation") }}
	{{ padRight (printf "%s?:" $field.APIName) (add $type.GoNameMaxLen 2) }} {{ $field.TSType }} | null;
	{{- else }}
	{{ padRight (printf "%s:" $field.APIName) (add $type.GoNameMaxLen 2) }} {{ $field.TSType }};
	{{- end }}
	{{- end }}
}

{{- if $type.APIName }}

export interface {{ $type.GoName -}} Response {
	{{- range $field := .Fields }}
	{{- if and $field.Optional (not (eq $field.APIName "id" "etag" "generation")) }}
	{{ padRight (printf "%s?:" $field.APIName) (add $type.GoNameMaxLen 2) }} {{ $field.TSType }} | null;
	{{- else }}
	{{ padRight (printf "%s:" $field.APIName) (add $type.GoNameMaxLen 2) }} {{ $field.TSType }};
	{{- end }}
	{{- end }}
}

{{- end }}
{{- end }}

export interface Metadata {
	id:           string;
	etag:         string;
	generation:   number;
}

interface FetchOptions {
	params?: URLSearchParams | null;
	headers?: Headers | null;
	prev?: any | null;
	body?: any | null;
}

class ClientCore {
	protected baseURL: URL;
	protected headers: Headers = new Headers();

	private static etag = Symbol('etag');

	constructor(baseURL: string) {
		this.baseURL = new URL(baseURL);
	}

	async debugInfo(): Promise<DebugInfo> {
		return this.fetch('GET', '_debug');
	}

	//// Generic

	async createName<T1, T2>(name: string, obj: T1): Promise<T2> {
		return this.fetch(
			'POST',
			encodeURIComponent(name),
			{
				body: obj,
			},
		);
	}

	async deleteName(name: string, id: string, opts?: UpdateOpts | null): Promise<void> {
		return this.fetch(
			'DELETE',
			`${encodeURIComponent(name)}/${encodeURIComponent(id)}`,
			{
				headers: this.buildUpdateHeaders(opts),
			},
		);
	}

	async findName<T>(name: string, shortID: string): Promise<T> {
		const opts: ListOpts = {
			filters: [
				{
					path: "id",
					op: "hp",
					value: shortID,
				},
			],
		};

		const list = await this.listName<T>(name, opts);

		if (list.length != 1) {
			throw(new Error({
				messages: [
					"not found",
				],
			}));
		}

		return list[0]!;
	}

	async getName<T>(name: string, id: string, opts?: GetOpts | null): Promise<T> {
		return this.fetch(
			'GET',
			`${encodeURIComponent(name)}/${encodeURIComponent(id)}`,
			{
				headers: this.buildGetHeaders(opts),
				prev: opts?.prev,
			},
		);
	}

	async listName<T>(name: string, opts?: ListOpts | null): Promise<T[]> {
		return this.fetch(
			'GET',
			`${encodeURIComponent(name)}`,
			{
				params: this.buildListParams(opts),
				headers: this.buildListHeaders(opts),
				prev: opts?.prev,
			},
		);
	}

	async replaceName<T1, T2>(name: string, id: string, obj: T1, opts?: UpdateOpts | null): Promise<T2> {
		return this.fetch(
			'PUT',
			`${encodeURIComponent(name)}/${encodeURIComponent(id)}`,
			{
				headers: this.buildUpdateHeaders(opts),
				body: obj,
			},
		);
	}

	async updateName<T1, T2>(name: string, id: string, obj: T1, opts?: UpdateOpts | null): Promise<T2> {
		return this.fetch(
			'PATCH',
			`${encodeURIComponent(name)}/${encodeURIComponent(id)}`,
			{
				headers: this.buildUpdateHeaders(opts),
				body: obj,
			},
		);
	}

	// TODO: Add streamGetName
	// TODO: Add streamListName

	private buildListParams(opts: ListOpts | null | undefined): URLSearchParams {
		const params = new URLSearchParams();

		if (!opts) {
			return params;
		}

		if (opts.stream) {
			params.set('_stream', opts.stream);
		}

		if (opts.limit) {
			params.set('_limit', `${opts.limit}`);
		}

		if (opts.offset) {
			params.set('_offset', `${opts.offset}`);
		}

		if (opts.after) {
			params.set('_after', `${opts.after}`);
		}

		for (const filter of opts.filters || []) {
			params.set(`${filter.path}[${filter.op}]`, filter.value);
		}

		for (const sort of opts.sorts || []) {
			params.append('_sort', sort);
		}

		return params;
	}

	private buildListHeaders(opts: ListOpts | null | undefined): Headers {
		const headers = new Headers();

		if (!opts) {
			return headers;
		}

		if (opts.prev) {
			const etag = Object.getOwnPropertyDescriptor(opts.prev, ClientCore.etag)!.value;
			headers.set('If-None-Match', etag);
		}

		return headers;
	}

	private buildGetHeaders(opts: GetOpts | null | undefined): Headers {
		const headers = new Headers();

		if (!opts) {
			return headers;
		}

		if (opts.prev) {
			headers.set('If-None-Match', `"${(<Metadata>opts.prev).etag}"`);
		}

		return headers;
	}

	private buildUpdateHeaders(opts: UpdateOpts | null | undefined): Headers {
		const headers = new Headers();

		if (!opts) {
			return headers;
		}

		if (opts.prev) {
			headers.set('If-Match', `"${(<Metadata>opts.prev).etag}"`);
		}

		return headers;
	}

	protected async fetch(method: string, path: string, opts?: FetchOptions): Promise<any> {
		const url = new URL(path, this.baseURL);

		if (opts?.params) {
			url.search = `?${opts.params.toString()}`;
		}

		const reqOpts: RequestInit = {
			method: method,
			headers: new Headers(this.headers),
			mode: 'cors',
			credentials: 'omit',
			referrerPolicy: 'no-referrer',
			keepalive: true,
		}

		if (opts?.headers) {
			for (const [k, v] of opts.headers) {
				(<Headers>reqOpts.headers).append(k, v);
			}
		}

		if (opts?.body) {
			reqOpts.body = JSON.stringify(opts.body);
			(<Headers>reqOpts.headers).set('Content-Type', 'application/json');
		}

		const req = new Request(url, reqOpts);

		const resp = await fetch(req);

		if (opts?.prev && resp.status == 304) {
			return opts.prev;
		}

		if (!resp.ok) {
			throw new Error(await resp.json());
		}

		if (resp.status == 200) {
			const js = await resp.json();

			if (Array.isArray(js)) {
				Object.defineProperty(js, ClientCore.etag, {
					value: resp.headers.get('ETag'),
				});
			}

			return js;
		}
	}
}

export class Client extends ClientCore {
	constructor(baseURL: string) {
		super(baseURL);
	}

	{{- if .AuthBasic }}

	setBasicAuth(user: string, pass: string) {
		const enc = btoa(`${user}:${pass}`);
		this.headers.set('Authorization', `Basic ${enc}`);
	}
	{{- end }}

	{{- if .AuthBearer }}

	setAuthToken(token: string) {
		this.headers.set('Authorization', `Bearer ${token}`);
	}
	{{- end }}

	{{- range $type := .Types }}
	{{- if not $type.APIName }} {{- continue }} {{- end }}

	//// {{ $type.APINameCamel }}

	async create {{- $type.APINameCamel -}} (obj: {{ $type.GoName -}} ): Promise< {{- $type.GoName -}} Response> {
		return this.createName(" {{- $type.APIName -}} ", obj);
	}

	async delete {{- $type.APINameCamel -}} (id: string, opts?: UpdateOpts | null): Promise<void> {
		return this.deleteName(" {{- $type.APIName -}} ", id, opts);
	}

	async find {{- $type.APINameCamel -}} (shortID: string): Promise< {{- $type.GoName -}} Response> {
		return this.findName(" {{- $type.APIName -}} ", shortID);
	}

	async get {{- $type.APINameCamel -}} (id: string, opts?: GetOpts | null): Promise< {{- $type.GoName -}} Response> {
		return this.getName(" {{- $type.APIName -}} ", id, opts);
	}

	async list {{- $type.APINameCamel -}} (opts?: ListOpts | null): Promise< {{- $type.GoName -}} Response[]> {
		return this.listName(" {{- $type.APIName -}} ", opts);
	}

	async replace {{- $type.APINameCamel -}} (id: string, obj: {{ $type.GoName -}}, opts?: UpdateOpts | null): Promise< {{- $type.GoName -}} Response> {
		return this.replaceName(" {{- $type.APIName -}} ", id, obj, opts);
	}

	async update {{- $type.APINameCamel -}} (id: string, obj: {{ $type.GoName -}}, opts?: UpdateOpts | null): Promise< {{- $type.GoName -}} Response> {
		return this.updateName(" {{- $type.APIName -}} ", id, obj, opts);
	}

	// TODO: Add streamGet
	// TODO: Add streamList

	{{- end }}
}

export class Error {
	messages: string[];

	constructor(json: JSONError) {
		this.messages = json.messages;
	}

	toString(): string {
		return this.messages[0] ?? 'error';
	}
}
